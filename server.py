from flask import Flask, request, jsonify, send_file
from PIL import Image
from flask_cors import CORS
import io
import base64
import time
import os  
import os.path as osp
import glob
import cv2
import numpy as np
import torch
import functools
import torch.nn as nn
import torch.nn.functional as F


import numpy as np
from tensorflow.keras.models import load_model
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt


app = Flask(__name__)
CORS(app)

# Load the TensorFlow model
path = './generator_2.h5'
generator = load_model(path)

#Load the pytorch Model

model_path = 'esr_latest.pth'  
if torch.cuda.is_available():
    device = torch.device('cuda:0')  # Use the first GPU (index 0)
    print('Using CUDA (GPU)')
else:
    device = torch.device('cpu')  # Fallback to CPU if CUDA is not available
    print('Using CPU')

test_img_folder = 'results/*'    ###PATH TO LOW RESOLUTION IMAGES GENERATED BY PIX2PIX model
# test_img_folder = '../../outputs1/*'

# Initialize plot_path as a global variable
plot_path = ''

def normalize_images(images):
    images = np.array(images)
    normalized_images = (images / 127.5) - 1
    normalized_images = normalized_images.astype(np.float32)
    return normalized_images

@app.route('/process_image', methods=['POST'])
def process_image():
    try:
        # Get the image data from the request
        data = request.get_json()
        image_data_url = data['image']['dataUrl']
        stroke_colors = data['strokeColors']
        print(stroke_colors)

        # Convert the data URL to a NumPy array
        # decode image data from frontend to use pillow
        ip_img = Image.open(io.BytesIO(base64.b64decode(image_data_url.split(',')[1])))
        ip_img = ip_img.resize((256, 256))
        
        #convert to 3 channels
        ip_img = ip_img.convert('RGB')
        
        img = normalize_images(ip_img)
        img_array = np.array(img)
        
        img_array_batch = np.expand_dims(img_array, axis=0)
        
        # Predict using the model
        result = generator.predict(img_array_batch)

        # Assuming images are normalized to [-1, 1]
        processed_image = (result[0] * 0.5 + 0.5)



        # Convert NumPy array to PIL Image
        processed_image_pil = Image.fromarray((processed_image * 255).astype(np.uint8))
        print(processed_image_pil)
        # processed_image_pil_resized = processed_image_pil.resize(ip_img.size)
        # print(processed_image_pil_resized)

        # Plot and save the generated images
        plt.figure(figsize=(256/72, 256/72), dpi=72)
        plt.imshow(processed_image)
        plt.axis('off')
        plt.tight_layout()
        # Save the plot as an image file
        timestamp = int(time.time())
        plot_path = f'./results/path_to_plot_{timestamp}.png'
        plt.savefig(plot_path, bbox_inches= 0, pad_inches=0)
        plt.close()

        # Send the path of the saved image back to the frontend
        return jsonify({'processedImage': plot_path})
    except Exception as e:
        return jsonify({'error': str(e)})
        
@app.route('/results/<filename>')
def serve_plot(filename):
    image_path = os.path.join(app.root_path, 'results', filename)
    return send_file(image_path, mimetype='image/png')




@app.route('/SR', methods=['POST'])
def super_resolution():
    try:
        def make_layer(block, n_layers):
            layers = []
            for _ in range(n_layers):
                layers.append(block())
            return nn.Sequential(*layers)

        class ResidualDenseBlock_5C(nn.Module):
            def __init__(self, nf=64, gc=32, bias=True):
                super(ResidualDenseBlock_5C, self).__init__()
                self.conv1 = nn.Conv2d(nf, gc, 3, 1, 1, bias=bias)
                self.conv2 = nn.Conv2d(nf + gc, gc, 3, 1, 1, bias=bias)
                self.conv3 = nn.Conv2d(nf + 2 * gc, gc, 3, 1, 1, bias=bias)
                self.conv4 = nn.Conv2d(nf + 3 * gc, gc, 3, 1, 1, bias=bias)
                self.conv5 = nn.Conv2d(nf + 4 * gc, nf, 3, 1, 1, bias=bias)
                self.lrelu = nn.LeakyReLU(negative_slope=0.2, inplace=True)
            def forward(self, x):
                x1 = self.lrelu(self.conv1(x))
                x2 = self.lrelu(self.conv2(torch.cat((x, x1), 1)))
                x3 = self.lrelu(self.conv3(torch.cat((x, x1, x2), 1)))
                x4 = self.lrelu(self.conv4(torch.cat((x, x1, x2, x3), 1)))
                x5 = self.conv5(torch.cat((x, x1, x2, x3, x4), 1))
                return x5 * 0.2 + x
        class RRDB(nn.Module):
            def __init__(self, nf, gc=32):
                super(RRDB, self).__init__()
                self.RDB1 = ResidualDenseBlock_5C(nf, gc)
                self.RDB2 = ResidualDenseBlock_5C(nf, gc)
                self.RDB3 = ResidualDenseBlock_5C(nf, gc)
            def forward(self, x):
                out = self.RDB1(x)
                out = self.RDB2(out)
                out = self.RDB3(out)
                return out * 0.2 + x
        class RRDBNet(nn.Module):
            def __init__(self, in_nc, out_nc, nf, nb, gc=32):
                super(RRDBNet, self).__init__()
                RRDB_block_f = functools.partial(RRDB, nf=nf, gc=gc)
                self.conv_first = nn.Conv2d(in_nc, nf, 3, 1, 1, bias=True)
                self.RRDB_trunk = make_layer(RRDB_block_f, nb)
                self.trunk_conv = nn.Conv2d(nf, nf, 3, 1, 1, bias=True)
                self.upconv1 = nn.Conv2d(nf, nf, 3, 1, 1, bias=True)
                self.upconv2 = nn.Conv2d(nf, nf, 3, 1, 1, bias=True)
                self.HRconv = nn.Conv2d(nf, nf, 3, 1, 1, bias=True)
                self.conv_last = nn.Conv2d(nf, out_nc, 3, 1, 1, bias=True)
                self.lrelu = nn.LeakyReLU(negative_slope=0.2, inplace=True)
            def forward(self, x):
                fea = self.conv_first(x)
                trunk = self.trunk_conv(self.RRDB_trunk(fea))
                fea = fea + trunk
                fea = self.lrelu(self.upconv1(F.interpolate(fea, scale_factor=2, mode='nearest')))
                fea = self.lrelu(self.upconv2(F.interpolate(fea, scale_factor=2, mode='nearest')))
                out = self.conv_last(self.lrelu(self.HRconv(fea)))
                return out
        model = RRDBNet(3, 3, 64, 23, gc=32)
        model.load_state_dict(torch.load(model_path), strict=True)
        model.eval()
        model = model.to(device)
        print('Model path {:s}. \nTesting...'.format(model_path))
        image_paths = glob.glob(test_img_folder)
        latest_image_path = max(image_paths, key=lambda x: int(''.join(filter(str.isdigit, osp.splitext(osp.basename(x))[0]))))
        base = osp.splitext(osp.basename(latest_image_path))[0]
        # Read the latest image
        img = cv2.imread(latest_image_path, cv2.IMREAD_COLOR)
        img = img * 1.0 / 255
        img = torch.from_numpy(np.transpose(img[:, :, [2, 1, 0]], (2, 0, 1))).float()
        img_LR = img.unsqueeze(0)
        img_LR = img_LR.to(device)
        with torch.no_grad():
            output = model(img_LR).data.squeeze().float().cpu().clamp_(0, 1).numpy()
        output = np.transpose(output[[2, 1, 0], :, :], (1, 2, 0))
        output = (output * 255.0).round()
        import time

        # Generate current timestamp
        timestamp = int(time.time())
        # Append timestamp to output_path
        output_path = f'./SR/SR_{base}_{timestamp}.png'

        cv2.imwrite(output_path, output)

        # Send the path of the saved image back to the frontend
        return jsonify({'processedImage': output_path})
    except Exception as e:
        return jsonify({'error': str(e)})

@app.route('/SR/<filename>')
def serve_plot_SR(filename):
    image_path = os.path.join(app.root_path, 'SR', filename)
    return send_file(image_path, mimetype='image/png')



if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)